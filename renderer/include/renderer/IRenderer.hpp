#pragma once

#include <vector>
#include <renderer/APIs.hpp>
#include <renderer/NativeWindowHandle.hpp>
#include <renderer\DescriptorType.hpp>
#include <renderer\ShaderStage.hpp>
#include <renderer\IUniformBuffer.hpp>
#include <renderer\IComputePipeline.hpp>
#include <renderer\IComputeProgram.hpp>

namespace Renderer
{
	class IRenderer
	{
	public:
		IRenderer();
		// Starts the renderer, this class is inherited by the parent class and it will define the function body
		virtual bool Start(NativeWindowHandle* window_handle) = 0;
		// Update the renderer, this class is inherited by the parent class and it will define the function body
		virtual void Update() = 0;
		// Stop the renderer, this class is inherited by the parent class and it will define the function body
		virtual void Stop() = 0;
		// Rebuild the rendering platform when a event takes place that it is required, such as a screen resize
		virtual void Rebuild() = 0;

		// Creates a instance of the renderer based on the chosen API. this IRenderer can be cast into the parent class
		static IRenderer* CreateRenderer(const RenderingAPI api);
		// Call the update function on all of the renderer's that have been created
		static void UpdateAll();
		// Remove the renderer from the list of renderers to be updated when calling UpdateAll, the renderer will still work as a stand alone renderer
		static void UnregisterRenderer(IRenderer* renderer);

		virtual IUniformBuffer* CreateUniformBuffer(void* dataPtr, unsigned int indexSize, unsigned int elementCount, DescriptorType descriptor_type, ShaderStage shader_stage, unsigned int binding) = 0;

		virtual IComputePipeline* CreateComputePipeline(const char* path, unsigned int x, unsigned int y, unsigned int z) = 0;

		virtual IComputeProgram* CreateComputeProgram() = 0;
	private:
		// Store all renderers generated by the CreateRenderer class
		static std::vector<IRenderer*> m_renderers;
	};
}